### 为什么用Go?

- 刚开始是因为了解到越来越多的公司使用go语言，就调研了一下go语言的优势，那会对于 Go 语言的了解并不够深入
    - 天然的高并发：采用了轻量级的协程（goroutine）和通信机制（channel），使得并发编程变得简单和高效
    - 语法简洁而富有表现力，代码可读性强，函数和包的设计鼓励模块化和解耦，使得代码更易于维护和扩展
    - 自动垃圾回收机制，使得内存管理变得简单且高效
    - 跨平台支持和部署便捷性
- 后续在使用go的过程中，让我真正爱上了这⻔语言，并对它的特性有了更深入的理解，同时，我也开始对一些被人们吐槽的问题有了更多的包容性，比如 错误处理if error，less is more，通过通信来共享内存等，通过理解这些特性，我才真正意识到这只小鼹鼠有多么的可爱~
- 语言只是工具，好坏在于如何使用，**Go语言不是万能的，但它的确能有效地解决某些问题**

### Go设计哲学
Todo
- Less is more:


### Go和Python区别？

- **执行速度快 vs 相对较慢**
- **语法简单 vs 语法优雅**
- **网络服务 vs 数据分析、机器学习**
- **内置并发 vs 需要第三方库**
- **静态类型 vs 动态类型**
- Go语言和Python都有各自的优势,具体选择还是要看企业需求和实际使用情况

### Go VS C++

go的结构体、组合、接口对应了C++的封装，继承，多态

- 结构体 == 封装：
    - 在 Go 语言中，结构体（struct）是一种用户自定义的数据类型，用于将不同类型的变量组合在一起。C++ 通过类（class）来实现封装。类将数据成员（类似于 Go 结构体中的字段）和成员函数组合在一起
    - Go 结构体通过字段名大小写来控制访问权限，C++ 通过 private、public 等访问修饰符来控制。Go相对来说规则更简洁，但在复杂的访问控制场景下可能不如 C++ 灵活
- 组合 == 继承：
    - Go 语言没有像 C++ 那样的传统继承机制，而是通过组合来实现代码复用。组合是指将一个结构体嵌入到另一个结构体中，使得外部结构体可以直接访问内部结构体的可访问成员
    - 组合的方式使得代码结构更加清晰，不像继承那样可能会出现复杂的层次结构和方法覆盖等问题，避免了继承的复杂性
- 接口 == 多态：
    -  Go 语言中，接口是一种抽象类型，它定义了一组方法签名，但没有具体的实现。。一个类型只要实现了接口定义的所有方法，就自动实现了这个接口
    - C++ 的多态依赖于类之间的继承层次结构和虚函数的重写机制




### Go为什么跨平台

https://zhuanlan.zhihu.com/p/621257358
https://cloud.tencent.com/developer/article/2311749

java跨平台：

- 可以在任意系统中编写Java程序，并生成.class字节码文件，但要想实现跨平台，则需要安装Windows、Linux、或Mac等系统自己版本的JVM虚拟机。然后把字节码文件放到不同系统下的JVM虚拟机中运行，这样就实现了所谓的跨平台
- **Java跨平台的根本原理，就是通过JVM虚拟机来实现的**！但你要知道，Java语言是跨平台的，JVM却不是跨平台的，不同的操作系统有不同版本的JVM！

go跨平台：

- Go提供了简单易用的跨平台编译特性，使得在一个平台上构建其他平台的二进制程序变得轻松
- 通过设置环境变量GOOS和GOARCH来指定目标操作系统和处理器架构。GOOS表示目标操作系统，如linux、windows、darwin（macOS）等；GOARCH表示目标处理器架构，如386、amd64、arm、arm64等
- 然后运行go build XXX.go即可生成相应的可执行程序
- **可以理解为“翻译”，指定国家语言，即可在一定程度上帮助程序员更专注的写代码而不是折腾各种软硬件环境**

### Go 编译流程

1. 词法分析:拆为token
2. 句法分析:生成语法树
3. 语义分析:逃逸分析，函数内联等。
4. 中间码生成:生成的是SSA码，和平台无关。
5. 代码优化
6. 机器码生成:先生成Plan9汇编代码，最后编译为机器码，输出的机器码为.a文件。这一步完成从平台无关到平台相关的改变
7. 链接: 把所有的.a文件变成一个可执行文件

### Go程序入口
1. 接受argc和argv参数
2. 初始化g0执行栈，g0是一个为了调度协程而产生的协程，一个母协程。
3. 进行运行时检测:
    - 检查各种类型的长度
    - 检查结构体字段的偏移量
    - 检查指针操作
    - 检查CAS操作
    - 检查atomic原子操作
    - 检查栈的大小是否是2的n次幂
4. 初始化调度器:全局栈空间内存分配，堆内存空间的初始化，初始化当前系统线程，算法初始化(hash，map)，垃圾回收器参数初始化等
5. 创建新协程，也就是主协程，执行runtime.main
6. 创建M，调度主协程，
7. 主协程执行主函数: 执行runtime包的init方法，启动GC，执行用户包以来的init方法，执行用户主函数main.main()

### GO Runtime
- Runtime作为程序的一部分打包生成二进制，Runtime和用户程序一起运行。这一点和Java不一样，Java的运行时需要安装JVM,看网页需要安装浏览器。下载一个Go程序后，不需要再安装GO的runtime。
- Runtime的能力:内存管理，垃圾回收，GMP协程调度，可以屏蔽系统差异，所以Go可以跨平台
- 用户和Runtime之间的交互可以直接调用Runtime的函数，比如一些关键字:
    - go ->newproc
    - new->newobject
    - make->makeslice,makechain,makemap...
    - <- : chansend1,chanrecy1

### Go内存管理

物理、虚拟内存  -> mheap堆 → HeapArena -> page→mspan -> mcentral -> mcache -> 总结内存模型 -> 堆内存分配 -> 栈内存分配

- Go 语言是如何进行内存管理的呢？首先，让我们来讨论它的内存模型。我们都知道计算机的物理内存条，但为了最大化利用物理内存并实现进程之间的内存隔离，操作系统将其划分为以⻚为单位的虚拟内存。因此，程序内部可以直接操作的是虚拟内存，通过内存管理单元（MMU）将其映射到物理内存。在 64 位操作系统下，虚拟内存的大小约为 256 TB，远大于物理内存；
- 对于进程内部，堆mheap是所有对象的内存起源，是 程序运行时中最大的临界共享资源，这意味着每次存取都要加锁，在性能层面是一件很可怕的事情，那么该如何管理和高效的使用这么一大块内存空间呢？
- Golang 借鉴了**Thread-Caching Malloc内存模型**，采用**分层思想**，使用**多级缓存**构建整个内存模型：
    - **heapArena** ：首先在**堆内存mheap**之上，将堆内存划分为 一个一个内存单元（HeapArena），每个单元大小为 64 MB，**heapArena** 是 mheap 向操作系统申请内存的单位
    - **page**：然后参考操作系统分页管理的思想，将每个 HeapArena划分为一个个大小为8KB的页 page，然后以page为单位组装成**不同级别**的mspan，mspan 是程序能够操作的最小内存单元
    - **mspan**： mspan大小为 page 的整数倍，且从 8B 到 80 KB 被划分为 67 种不同的规格，0 级用于处理更大的对象，上不封顶，分配对象时，会根据大小映射到不同规格的 mspan，从中获取空间.
    - **mcentral**：相同规格spanClass的 mspan 会被组织成双向链表，称为 mcentral，每个 mcentral 基于一把互斥锁管理，每个mcentral 下的 mspan 又分为两个链表，分别为有空间 mspan 链表 partial 和满空间 mspan 链表 full
    - **mcache**：**mcentral**是全局协程共享的，因此在访问时需要加锁，这可能导致锁饥饿的问题。为了解决这个问题，Go 借鉴了其 GPM 调度模型，在每个 M 上添加了一个本地缓存（mcache）；这样就不需要每次都从全局中心索引中获取 mspan 了。值得一提的是，由于在 GMP 模型中，当协程进行阻塞式系统调用时，会与 P 解绑，调用完成后可能会进入休眠队列。如果将 mcache 放置在 M上，可能会浪费内存。因此，**mcache 缓存的一组 mspan 实际上会放在 P 内部**。mcache 中包含每个Spanclass的两个 mspan，一个是 noscan 的，一个是 scan 的，总共有 136 个 mspan
- **多级缓存**：把堆内存划分为最小的page，然后组装成不同大小的mspan，用于分配给不同大小的对象，同时把锁的粒度也仅降低到Spanclass粒度
- **分层分配**：先从P本地的mcache中分配对应大小的mspan，不行再逐层向上申请，加锁访问该Spanclass的mcentral获取mspan，如果 mcentral  已满，将从 HeapArena 中换一组对应大小的mspan。如果所有的 HeapArena 都满了，将向操作系统申请一块新的虚拟内存单元 HeapArena

### Go垃圾回收机制

Go 语言在整个发展过程中，垃圾回收机制的演进为：标记清除法——>三色标记法+插入写屏障->三色标记法+混合写屏障 

- **标记-清除(STW)**：Go 最初的垃圾回收很简单，为了正确地清理垃圾，采用串行的方式进行标记-清理的工作，这个串行的过程叫做   STW （Stop The World）。就像它的名字一样，执行 GC 的整个过程，都会停止Goroutine 的工作。这非常影响程序的性能，所以后来 Go 一直在升级 GC 策略，都致力于在不影响程序安全性的情况下，减少 STW 的时间。
- **三色标记法**：既然串行这么慢，能否并发地进行 GC 呢？并发进行GC，其中的难点在于如何标记，于是 Go 将直接标记换成了三色标记法，所有对象初始化白色，然后遍历根对象，将其标记为灰色，遍历所有灰色对象，通过可达性分析跟踪其引用关系，引用的对象标记为灰色，自己标记为黑色；继续遍历灰色对象，直到遍历结束，最后只剩下黑、白对象，回收白色对象
- **对象丢失：**这一过程其实并不复杂，但注意此时用户程序正和 GC 并发地运行，如果此时突然有个**还未扫描的灰色对象的下游对象(白)指向了一个已分析扫描完成的黑色对象**。那么当此轮 GC 扫描完成的时候，那个突然改变指向插入黑色对象中的下游对象，就会被当做垃圾清理掉！
- **屏障机制：**出现这种问题的本质就是那些下游对象不听话，在 GC 期间乱跑，并且跑到了已经扫描分析完成的黑色对象上。但用户程序和 GC 是并发执行的，也不能完全怪它们。那么这时候就有两种思路了，第一种像以前一样，在扫描时进入STW 时间。但这肯定不是我们想要的，那么又要避免这种“插入”问题，就引入了另一种思路，在扫描时增加**写屏障机制(额外的判断处理逻辑)**来限制住乱跑的那些对象，主要有以下两种：
    - 可以看到错误原因是：
        
        1、一个白色对象被黑色对象引用了
        
        2、之前与此白色对象连接的灰色对象连接断开了
        
        同时满足这两条，才会出现错误
        
        所以破坏任意一条，就可以避免错误回收活跃对象，由此就有了强三色不变性和弱三色不变性
        
    - **插入写屏障**：插入对象时触发，强三色不变式
        - 只要有对象被**插入黑色对象**上，我们就将它的颜色**设置为灰色**，放入灰色队列中等待分析扫描。这样在此轮扫描结束后，最终也能保证不会误清理掉乱跑的对象
        - **栈上STW**：但是由于 Go 中对栈要求非常快速响应速度，以供函数调用频繁地入栈和出栈，在栈上使用写屏障会影响性能。所以**插入写屏障只能在堆上使用**。但我们也得防止栈里面出现这种“插入”问题，所以在扫描完成后会进入 STW 模式重新扫描栈上的对象，保证新引用的白色对象被添加不被清除，虽然也需要 STW，但由于协程栈通常很小，STW 的时间变短了
    - **删除写屏障**：删除对象时触发，弱三色不变式
        - 当有一个待扫描对象突然删除了它某一下游对象时，防止跑掉的下游对象被添加到某已扫描的黑色对象上，我们**将被删除的下游对象设置为灰色**，放入灰色队列中等待分析扫描，因此如果没有被引用的话，会保护一轮被删除的对象，延迟一轮被真正删除，所以**回收精读低**
        - 堆和栈上都使用
- **混合写屏障：结合插入和删除的优点，减少了插入写屏障的栈上STW**
    - **栈上插入**：GC开始就将**栈上的可达对象扫描并标记为黑色**，并且GC期间，**任何在栈上创建的新对象**，**均为黑色**，正常删除对象，栈上不触发屏障机制，也就是说，**栈上的节点都为黑色**，这样子之后就**不需要再进行STW额外扫描标记**了，解决了插入屏障的缺点(栈上创建是黑色，删除也还是黑色，引用先是灰色再变黑)
    - 堆上被删除的对象标记为灰色（可能被栈上对象引用）
    - 堆上被添加的对象标记为灰色


### GMP并发模型
GM 模型 -> 存在的问题 -> 引入 GMP -> 如何解决这些问题的

- GMP模型中的G代表Go 语言中的协程，M代表操作系统工作线程，P代表处理器
- **早期GM**：GMP也是一步步发展优化的结果，早期是没有P的，就是GM模型：通过一个全局队列存放所有的G，然后M 想要执行G、放回 G 都必须访问全局 G 队列，并且 M 有多个，即多线程访问同一资源需要加锁进行保证互斥 / 同步，所以全局 G 队列是有互斥锁进行保护的
- **存在问题**：
    - 全局**锁竞争**造成巨大的性能开销
    - **Goroutine 传递问题**：某个M刚创建的 G 放到了全局队列，而不是本地 M 执行，M 之间传递G导致不必要的开销和延迟
    - **数据局部性不好**：G 当前在 M运行后对 M 的内存进行了预热，但是后续 G 调度到同一个 M 的概率不高，所以数据局部性不好
- **GMP模型**：所以为了解决GM模型中全局队列带来的性能问题，引入了处理器   **P**  作为 G 和 M 之间的中介(中间层)，每个 M 对应一个 P，P 主要维护与其关联的M的**本地协程队列**
    - **减少锁竞争**：有了 P 之后，M 不再直接从全局队列中获取 G，而是从其关联的 P 的本地队列中获取一个可运行的协程执行调度循环，从而大大减少了访问全局队列时的锁竞争问题
    - **减少G传递**：当新建协程时，会优先考虑放入对应 P 的本地队列中执行，满了才放全局队列，所以也在一定程度上保证了数据局部性
    - **运行流程**：线程M想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 先会尝试加锁从全局队列拿一批 G 放到 P 的本地队列，全局队列没有的话。M则会从其他 P 的本地队列偷一半放到自己 P 的本地队列(**work stealing 机制** )。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去，当一个线程M因为G进行系统调用而阻塞时，该M会释放所绑定的P，把P交接给其他空闲的M执行(**hand off 机制**)，当 M 系统调用结束时候，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列。如果获取不到 P，那么这个线程 M 变成休眠状态， 加入到空闲线程中，然后这个 G 会被放入全局队列中
        - M 与 P 的数量没有绝对关系，一个 M 阻塞，P 就会去M的休眠队列取一个或者创建一个 新的M，P一般等于CPU核心数，Go语言本身允许最多10000个线程M
    - 抢占式调度：基于协作和信号的两种抢占式调度，使协程能够并发执行，避免其他协程饥饿；当所有 M 的调度循环执行了 61 次后，会从全局队列中随机选择一个 G 放入某个 P 中，这是为了防止全局协程饥饿
    
    - P在程序启动时依据GOMAXPROCS初始化完成
        - **M0**：M0 是启动程序后（进程）的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，**M0 负责执行进程初始化操作和启动第一个 G**， 在之后 M0 就和其他的 M 一样了
        - **G0**：G0 是每次启动一个 M 都会第一个创建的 gourtine，**G0 仅用于负责调度的 G**，G0 不指向任何可执行的函数，**每个 M 都会有一个自己的 G0**。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0
        
- 本质：通过Process处理器P将Goroutine协程G调度到machine内核线程M上面去，然后操作系统调度器将内核线程放到CPU上去执行
- 核心思想：
    - **复用线程：压榨！！**
        - **work stealing 机制**：自己的活干完了就帮别人干
        - **hand off 机制**：自己干不了也给别人干
        - **反正不让线程闲着，除非阻塞了**
    - **多CPU，多P并行工作**
    - **抢占式调度，防止协程饥饿**
    - **弱化全局队列，采用本地队列，减少锁竞争**
- 示例：
    
    ```go
    package main
    import "fmt"
    func main() {
    fmt.Println("Hello world")
    }
    ```
    
    1. runtinme创建最初的m0线程和用于m0调度的g0协程
    2. 调度器初始化工作：初始化 m0、栈、垃圾回收，以及创建和初始化由 GOMAXPROCS 个 P 构成的 P 列表
    3. 创建main协程 G ，加入m0绑定的P的本地队列
    4. m0启动，从绑定的P本地队列获取G
    5. M运行G
    6. G运行结束

